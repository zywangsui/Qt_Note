# 1.信号槽

# 2.元对象系统
Qt通过提供一个独立的moc工具解决问题，moc用于解析Q_OBJECT类的定义并且通过C++函数提供的信息，
因此可以在任意C++编译器上工作
该机制工作如下：
a.Q_OBJECT宏声明了每一个QObjet子类必须实现的内省函数
b.moc工具生成用于a中声明的所有函数和所有信号的实现
c.比如信号connect和disconnect是由Q_OBJECT的成员函数使用内省函数来完成他们的工作

元对象工具：
1.Qt的信号和槽机制是采用C++标准实现，使用预处理器和Qt所包括的moc，moc读取头文件，生成必要的代码，以支持信号槽
2.qmake生成的makefiles自动调用moc，所有编译规则自动包含到makefiles中，我不需要使用moc
3.头文件mysignal，moc工具在编译之前将根据这个文件，生成一个.moc.h的C++文件并交给编译器;

# QObject
连接了各个对象，从而有了信号槽机制
避免了无休止的通知和循环

Qobjects
把他们组织到一个对象树内
当你创建一个Qobj，把另外一个对象指定为父对象，这个qobj自己放到其孩子列表中，那么在福对象中，会自动析构他们的孩子。
可以通过objectName（） 查看名字
对象除了对象名字，还有他的类名，可以通过源对象来找到，源对象就是他的类的信息。
当一个对象即将删除时，会发送信号，可以解决指针无效引用的问题，防止删除空指针。自动删除所有信号连接，失联
对象可以接受event(),也可以过滤事件。
Q_OBJECT 这个宏 是 在信号槽机制所必须添加的。
源对象编译器，建议所有子类都添加Q_OBJ 以及所有控件和Widgets

QOBJet Class

func
	ObjName()
	setObjName() 当对象名字改变时，发出信号
ChlidEvent() 当子对象移除或增加 会触发信号

当一个object是Widget，并且他的parent = 0.，那么他是一个top-level 窗口

# QT对C++的拓展是
Meta object compiler ，user interface compiler
这个是个工具，和C++编译器一起

槽函数 的参数 不能拥有变量名称，只能int，string，float
第五个参数是指 判断信号和槽 在不在同一个线程里
当第五个参数是2：
	槽函数不会马上执行，当控制流返回事件循环时，再执行。接收事件的循环才会执行，在接收对象的线程里执行
当第五个参数是3: (必须在不同的线程中使用)
	信号的发送者要等待槽函数的返回，虽然在不同的线程，在队列取出信号 再执行对应的槽函数 结束后 唤醒1线程，也就是主程序要等待槽函数线程完成后，在执行。容易引起死锁
	比如 同一个线程 使用参数3 导致无限等待
当第五个参数是4:
	会提示 如果是重复连接，(提示用户避免 同一个信号对同一个槽函数 进行重复连接)


# 3.事件模型
